<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title type="html">PrimeFaces on Quarkus made simple</title><link rel="alternate" href="https://www.mastertheboss.com/web/primefaces/primefaces-on-quarkus-made-simple/" /><author><name>F.Marchioni</name></author><id>https://www.mastertheboss.com/web/primefaces/primefaces-on-quarkus-made-simple/</id><updated>2023-08-15T07:57:42Z</updated><content type="html">PrimeFaces is a renowned open-source UI component library for JSF-based web applications. It provides an extensive set of rich, customizable UI components that simplify the process of building feature-rich and visually appealing user interfaces. In this article we will learn how to integrate its library in Quarkus applications. This is the second round of article ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>Set up a continuous integration pipeline with Ansible Automation Platform &amp; GitLab</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/08/15/continuous-integration-pipeline-ansible-gitlab" /><author><name>Nagesh Rathod</name></author><id>6a764479-4640-4244-9a38-eafab5c34d36</id><updated>2023-08-15T07:00:00Z</updated><published>2023-08-15T07:00:00Z</published><summary type="html">&lt;p&gt;In modern software development practices, &lt;a href="https://developers.redhat.com/topics/automation"&gt;automation&lt;/a&gt; plays a crucial role in streamlining processes and ensuring efficient and reliable deployments. &lt;a href="https://developers.redhat.com/products/ansible/"&gt;Red Hat Ansible Automation Platform&lt;/a&gt; is an enterprise automation tool that allows you to define and manage configuration as code. GitLab, on the other hand, provides a robust &lt;a href="https://developers.redhat.com/topics/ci-cd/"&gt;CI/CD&lt;/a&gt; platform for managing code repositories and executing continuous integration and deployment pipelines.&lt;/p&gt; &lt;p&gt;Integrating Ansible Automation Platform into GitLab CI pipelines (as illustrated in Figure 1) enables organizations to automate infrastructure provisioning and configuration management alongside their application deployments. This tutorial will guide you through the process of integrating Ansible Automation Platform in a GitLab CI pipeline.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/1_5.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/1_5.png?itok=8tKjaehd" width="600" height="259" alt="Architectural diagram" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 1: Architecture diagram of GitLab CI/CD&lt;strong&gt; &lt;/strong&gt;with Ansible Automation Platform&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The pipeline starts when you commit changes in the GitLab code repository. The &lt;code&gt;gitlab-ci.yaml&lt;/code&gt; file contains the blueprints for the pipelines. The tasks for building and deploying are executed by GitLab Runner based on that file. Deployment occurs through the POST API call of Ansible's automation controller. Once the API call is made, the template will trigger and deploy the application in the appropriate environment. &lt;/p&gt; &lt;h2&gt;Prerequisites&lt;/h2&gt; &lt;p&gt;Before proceeding, make sure the following prerequisites are installed on your system:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;a href="https://developers.redhat.com/articles/2023/01/01/how-install-red-hat-ansible-automation-platform-rhel-9"&gt;Ansible Automation Platform&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://about.gitlab.com/install/"&gt;GitLab Runner&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;1. Create the GitLab CI Pipeline&lt;/h2&gt; &lt;p&gt;As we already know, GitLab CI is a popular tool for CI/CD. Integrating Ansible Automation Platform with GitLab CI gives you more possibilities to explore.&lt;/p&gt; &lt;p&gt;Before moving forward, make sure the GitLab Runner is live and running, as shown in Figure 2.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/2_8.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/2_8.png?itok=vaCPZIio" width="600" height="329" alt="runner up and running" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 2: The GitLab Runner is up and running.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The following &lt;code&gt;gitlab-ci.yaml&lt;/code&gt; file includes the build and deployment stage:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;stages:          # List of stages for jobs, and their order of execution   - build   - deploy build-job:       # This job runs in the build stage, which runs first.   stage: build   script:     - echo "Compiling the code..."     - echo "Compile complete." deploy-job:      # This job runs in the deploy stage.   stage: deploy   environment: production   script:     - curl -k -X POST --user '$ANSIBLE_CONTROLLER_USER:$ANSIBLE_CONTROLLER_PASSWORD' -H "Content-Type:application/json"  --data '{"limit":"ansible"}'  http://$ANSIBLE_CONTROLLER_URL/api/v2/job_templates/7/launch/ -k -L     - echo "deployment is done"&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;2. Add Red Hat API integration&lt;/h2&gt; &lt;p&gt;Red Hat offers &lt;a href="https://developers.redhat.com/api-catalog"&gt;API catalogs and documentation&lt;/a&gt; for its products. Here, we will use the &lt;a href="https://docs.ansible.com/automation-controller/latest/html/controllerapi/authentication.html#api-o"&gt;POST API&lt;/a&gt; to call Ansible controller.  &lt;/p&gt; &lt;h3&gt;Add variable in GitLab&lt;/h3&gt; &lt;p&gt;The variable is a secured way to pass your credentials in the pipeline. To add variables in the pipeline, follow these steps:&lt;/p&gt; &lt;ol&gt;&lt;li aria-level="1"&gt;Log in to the GitLab web console and from the left menu, select &lt;strong&gt;Settings&lt;/strong&gt;.&lt;/li&gt; &lt;li aria-level="1"&gt;Click on the &lt;strong&gt;CI/CD&lt;/strong&gt; section.&lt;/li&gt; &lt;li aria-level="1"&gt;At the center of the screen, you will see the fifth option listed as &lt;strong&gt;Variable.&lt;/strong&gt; Click the &lt;strong&gt;Expand&lt;/strong&gt; option in front of the variable.&lt;/li&gt; &lt;li aria-level="1"&gt;Click on &lt;strong&gt;Add Variable&lt;/strong&gt; option, then add the &lt;strong&gt;key&lt;/strong&gt; as given below and add &lt;code&gt;value&lt;/code&gt; as your credentials.&lt;/li&gt; &lt;li aria-level="1"&gt;Add the following variables:&lt;/li&gt; &lt;/ol&gt;&lt;ul&gt;&lt;li class="Indent1"&gt;&lt;code&gt;$ANSIBLE_CONTROLLER_USER&lt;/code&gt;&lt;/li&gt; &lt;li class="Indent1"&gt;&lt;code&gt;$ANSIBLE_CONTROLLER_PASSWORD&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/li&gt; &lt;li class="Indent1"&gt;&lt;code&gt;$ANSIBLE_CONTROLLER_URL&lt;/code&gt;&lt;/li&gt; &lt;/ul&gt;&lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/3_10.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/3_10.png?itok=H5XISwRV" width="600" height="189" alt="gitlab ci variables" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 3: Adding variables for the pipeline.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;3. Start the pipeline&lt;/h2&gt; &lt;p&gt;We can see in Figure 3 that the YAML file contains the deployment stage. We'll use the &lt;a href="https://docs.ansible.com/automation-controller/latest/html/controllerapi/authentication.html#api-oauth2-auth"&gt;POST API&lt;/a&gt; to trigger the Ansible template. The template contains inventories, playbooks, host server credentials, secrets, etc.&lt;/p&gt; &lt;p&gt;To configure the template, refer to the following tutorials on bare-metal instances, &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt; clusters, and &lt;a href="https://developers.redhat.com/products/openshift/overview"&gt;Red Hat OpenShift&lt;/a&gt; clusters:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;a href="https://developers.redhat.com/articles/2023/03/13/how-use-automation-controller-install-ms-sql#step_4__configuring_a_project "&gt;Creating a project&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://developers.redhat.com/articles/2023/02/28/how-employ-continuous-deployment-ansible-openshift#_configuring_job_templates "&gt;Configuring job templates&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;After adding the YAML, it is time to test the pipeline to ensure it is working. To test the pipeline, first commit the changes.&lt;/p&gt; &lt;p&gt;Log in to the GitLab web console and select &lt;strong&gt;CI/CD → Pipeline&lt;/strong&gt; from the left menu.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/4_7.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/4_7.png?itok=WSSK3qx-" width="600" height="305" alt="done pipeline" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 4: A successful pipeline run.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;To check that the pipeline template job executed successfully, log in to Ansible controller, navigate to &lt;strong&gt;Jobs&lt;/strong&gt;, and check for the latest job. You will get the following output in case of successful execution:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;PLAY [Application deployed] ****************************************************** TASK [Gathering Facts] ********************************************************* ok: [localhost]&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Continue your automation journey&lt;/h2&gt; &lt;p&gt;You can &lt;a href="https://developers.redhat.com/products/ansible/download"&gt;download the latest version of Ansible Automation Platform&lt;/a&gt; from our website at no cost. Get started with Ansible Automation Platform right away with &lt;a href="https://developers.redhat.com/products/ansible/getting-started"&gt;our interactive labs&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can find more Red Hat APIs and documentation in the &lt;a href="https://developers.redhat.com/api-catalog "&gt;API Catalog&lt;/a&gt;.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/08/15/continuous-integration-pipeline-ansible-gitlab" title="Set up a continuous integration pipeline with Ansible Automation Platform &amp; GitLab"&gt;Set up a continuous integration pipeline with Ansible Automation Platform &amp; GitLab&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Nagesh Rathod</dc:creator><dc:date>2023-08-15T07:00:00Z</dc:date></entry><entry><title>How to use Ansible Automation Platform from Azure Marketplace</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/08/14/how-use-ansible-automation-platform-azure-marketplace" /><author><name>Deepankar Jain, Himanshu Yadav</name></author><id>ff56efb1-8bb0-4b4b-b69b-09bb91e1649a</id><updated>2023-08-14T07:00:00Z</updated><published>2023-08-14T07:00:00Z</published><summary type="html">&lt;p&gt;In this article, you will learn about using the Red Hat Ansible Automation Platform from the Microsoft Azure Marketplace to automatically provision Azure resources.&lt;/p&gt; &lt;h2&gt;Overview of Ansible Automation Platform on Azure&lt;/h2&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/products/ansible/overview"&gt;Red Hat Ansible Automation Platform&lt;/a&gt; is available on the Azure Marketplace. It is a self-managed offering that enables enterprise-wide automation with the benefits of &lt;a href="https://www.redhat.com/en/technologies/management/ansible/azure"&gt;Ansible Automation Platform deployed on Azure cloud&lt;/a&gt;. This offering integrates seamlessly with native Azure services and the full ansible collection for Azure, co-developed and security-tested by Microsoft and Red Hat.&lt;/p&gt; &lt;p&gt;By combining the power of Red Hat Enterprise Linux, Red Hat OpenShift, and Azure services, developers can effectively scale their cloud infrastructure and leverage technologies like containers, Kubernetes, and hybrid cloud architecture. The collaboration between Red Hat and Azure offers a hybrid cloud environment that simplifies IT management, reduces complexity, and streamlines innovation.&lt;/p&gt; &lt;p&gt;You can obtain the Ansible Automation Platform self-managed offering from &lt;a href="https://azuremarketplace.microsoft.com/en-in/marketplace/apps/redhat.ansible-automation-platform?tab=Overview"&gt;Azure Marketplace&lt;/a&gt;. Once you have the subscription, refer to the comprehensive &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_ansible_automation_platform/2.1/html-single/red_hat_ansible_automation_platform_on_microsoft_azure_guide/index#aap-azure-install"&gt;documentation guide&lt;/a&gt; to set up and configure your Ansible Automation Platform on Azure.&lt;/p&gt; &lt;h2&gt;4 Components of Ansible Automation Platform&lt;/h2&gt; &lt;p&gt;The following is an overview of four components of Ansible Automation Platform.&lt;/p&gt; &lt;h3&gt;1. Execution environment&lt;/h3&gt; &lt;p&gt;Ansible Playbooks run on the execution environment platform. It includes everything needed to run the Ansible Automation Platform, including the runtime environment and dependencies. The Ansible Automation Platform provides a default execution environment that includes many commonly used modules and plugins.&lt;/p&gt; &lt;p&gt;However, you can also create custom execution environments tailored to your specific needs (Figure 1). This allows you to include only the modules and plugins required for your use case, reducing the size of the environment and minimizing security risks. You can manage the execution environment through the Ansible Automation Platform web console or the execution environment builder.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_11-58-11.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_11-58-11.png?itok=xXki-AuG" width="600" height="295" alt="Figure 1: The Execution Environment page." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The execution environment page of Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;To learn more about the execution environment and execution environment builder, refer to the &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/execution_environments.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;h3&gt;2. Inventories&lt;/h3&gt; &lt;p&gt;An inventory is a collection of hosts and groups managed and orchestrated by Ansible Automation Platform. It is used to define and organize the hosts and groups, targeted during an automation job. An inventory can be a static file, a dynamic inventory script, or an inventory plugin.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;A static inventory file is a simple text file that lists the hosts and their attributes.&lt;/li&gt; &lt;li&gt;A dynamic inventory script retrieves the inventory information from a third-party system or cloud provider in real time.&lt;/li&gt; &lt;li&gt;Inventory plugins provided for specific platforms, such as Amazon Web Services (AWS) and Microsoft Azure.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;In addition to hosts and groups, an inventory can also contain variables that are specific to a host or group. These variables can be used to customize how Ansible interacts with each host or group during a job.&lt;/p&gt; &lt;p&gt;As shown in Figure 2, inventories can be created, imported, and synchronized from external sources, such as cloud providers and configuration management databases (CMDBs). To learn more about inventories and how to create, manage, and work with them, refer to the official &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/inventories.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-05-22_10-23-30.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-05-22_10-23-30.png?itok=vznwedUp" width="600" height="281" alt="Figure 2: Inventory Page" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: The Inventory page in Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;3. Credentials&lt;/h3&gt; &lt;p&gt;In the credentials section of Ansible Automation Platform, you can manage and store sensitive information, such as usernames, passwords, and private keys. These credentials can be used in your playbooks and roles to authenticate with remote hosts, cloud providers, Kubernetes and OpenShift clusters, and other systems.&lt;/p&gt; &lt;p&gt;You can create a variety of credential types, such as SSH, sudo, Azure access keys, tokens, certificates, endpoints, and more. These credentials can be associated with a specific organization, project, or even a specific playbook or role. By using the credential section, you can centrally manage and secure your sensitive data, making it easier to rotate or revoke credentials as needed.&lt;/p&gt; &lt;p&gt;To learn more about using credentials in Ansible Automation Platform, refer to the official &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/credentials.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;h3&gt;4. Projects&lt;/h3&gt; &lt;p&gt;In the projects section of Ansible Automation Platform, you can manage your automation content, including playbooks, roles, collections, modules, and plugins. A project is a collection of related content, such as all the playbooks, roles, and other files that are related to a specific task or application.&lt;/p&gt; &lt;p&gt;Projects can be created and managed through the Ansible Automation Platform web UI or by utilizing the AWX CLI tool. They can be associated with a source control repository, such as Git or SVN, for version control and collaborative development.&lt;/p&gt; &lt;p&gt;Once you have a project set up, you can easily manage and organize your automation content, collaborate with other users, and ensure that your automation runs consistently across your infrastructure. You can also use projects to deploy automation content to remote servers, such as virtual machines or containers, for testing and production use.&lt;/p&gt; &lt;p&gt;For more information on managing projects in Ansible Automation Platform, you can refer to the &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/projects.html"&gt;user guide&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Job and workflow templates&lt;/h2&gt; &lt;p&gt;Job templates and workflow templates are powerful features of the Ansible Automation Platform that enable IT teams to automate and orchestrate their infrastructure management tasks.&lt;/p&gt; &lt;p&gt;A job template is a predefined set of tasks that can be executed on one or more hosts, making it a powerful tool for automating repetitive tasks, such as software installations or configuration changes. With job templates, we can define the tasks to be executed, the hosts on which they should run, and any required input parameters, all through an intuitive user interface.&lt;/p&gt; &lt;p&gt;On the other hand, workflow templates allow you to chain together multiple job templates to create a more complex process or workflow. With workflow templates, you can automate even the most complex tasks, such as deploying a multi-tiered application with multiple components and dependencies.&lt;/p&gt; &lt;p&gt;Together, job and workflow templates provide a comprehensive automation solution that streamlines IT operations and ensures that your infrastructure is configured and maintained consistently and efficiently.&lt;/p&gt; &lt;h2&gt;Find more resources&lt;/h2&gt; &lt;p&gt;To learn about using job templates to create virtual machines in Azure with Ansible Automation Platform, check out our article, &lt;a href="https://developers.redhat.com/articles/2023/04/27/step-step-guide-creating-virtual-machine-microsoft-azure-using-ansible"&gt;How to use Ansible to create a VM on Azure&lt;/a&gt;. For information on creating virtual machines and managing infrastructure using workflow templates, read our article, &lt;a href="https://developers.redhat.com/articles/2023/04/27/step-step-guide-creating-virtual-machine-microsoft-azure-workflow-using-ansible"&gt;How to use Ansible to create a VM on Azure via workflow&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;If you would like to understand automation more in-depth, refer to the &lt;a href="https://developers.redhat.com/e-books/it-executives-guide-automation"&gt;IT Executive's Guide to Automation&lt;/a&gt; e-book, which provides a comprehensive overview of automation and its impact on businesses. If you're new to &lt;a href="https://developers.redhat.com/products/ansible/overview"&gt;Ansible Automation Platform&lt;/a&gt;, you can &lt;a href="https://developers.redhat.com/products/ansible/download"&gt;download&lt;/a&gt; it and &lt;a href="https://developers.redhat.com/products/ansible/getting-started"&gt;get started by exploring interactive labs at no cost&lt;/a&gt;.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/08/14/how-use-ansible-automation-platform-azure-marketplace" title="How to use Ansible Automation Platform from Azure Marketplace"&gt;How to use Ansible Automation Platform from Azure Marketplace&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Deepankar Jain, Himanshu Yadav</dc:creator><dc:date>2023-08-14T07:00:00Z</dc:date></entry><entry><title type="html">Quarkus Newsletter #35 - August</title><link rel="alternate" href="https://quarkus.io/blog/quarkus-newsletter-35/" /><author><name>James Cobb</name></author><id>https://quarkus.io/blog/quarkus-newsletter-35/</id><updated>2023-08-14T00:00:00Z</updated><content type="html">Read Ladislav Thon’s article "On the Road to CDI Compatibility" to learn about the long road to make Quarkus compatible with CDI Lite. An Elsevier software engineer (Neil Stevens) writes about how to use Quarkus to improve Java functions with AWS Lambda in "Elsevier Tech: Writing a native Java Lambda...</content><dc:creator>James Cobb</dc:creator></entry><entry><title type="html">Quarkus 3.2.4.Final released - Maintenance release</title><link rel="alternate" href="https://quarkus.io/blog/quarkus-3-2-4-final-released/" /><author><name>Guillaume Smet</name></author><id>https://quarkus.io/blog/quarkus-3-2-4-final-released/</id><updated>2023-08-11T00:00:00Z</updated><content type="html">Today, we released Quarkus 3.2.4.Final, the fourth maintenance release of our 3.2 release train. It should be a safe upgrade for anyone already using 3.2. If you are not already using 3.2, please refer to the Quarkus 3.2 migration guide. And if you are not already using 3.0, please refer...</content><dc:creator>Guillaume Smet</dc:creator></entry><entry><title type="html">Kogito 1.42.0 released!</title><link rel="alternate" href="https://blog.kie.org/2023/08/kogito-1-42-0-released.html" /><author><name>Cristiano Nicolai</name></author><id>https://blog.kie.org/2023/08/kogito-1-42-0-released.html</id><updated>2023-08-10T23:19:34Z</updated><content type="html">We are glad to announce that the Kogito 1.42.0 release is now available! This goes hand in hand with , release. From a feature point of view, we have included a series of new features and bug fixes, including: * Fixed an issue that could make live reload not work as expected for workflows that use OpenAPI or gRPC. * Json schema validation: * Changed library from (org,json based)  to (jackson based) * Support nested json schema * Python support * Added support for python method call (embedded python script support was added in previous release) * Process definition addon that allows dynamically uploading SWF files to a Quarkus deployment (Experimental) For more details head to the complete . All artifacts are available now: * Kogito runtime artifacts are available on Maven Central. * Kogito examples can be found . * Kogito images are available on . * Kogito operator is available in the in OpenShift and Kubernetes. * Kogito tooling 0.31.0 artifacts are available at the . A detailed changelog for 1.42.0 can be found in . New to Kogito? Check out our website . Click the "Get Started" button. The post appeared first on .</content><dc:creator>Cristiano Nicolai</dc:creator></entry><entry><title>The benefits of deploying Ansible Automation Platform on AWS</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/08/10/benefits-deploying-ansible-automation-platform-aws" /><author><name>Deepankar Jain, Himanshu Yadav</name></author><id>7cad34ec-4b5d-4414-a3d2-639a2c8e6c2f</id><updated>2023-08-10T07:00:00Z</updated><published>2023-08-10T07:00:00Z</published><summary type="html">&lt;p&gt;In this article, you will learn how to use the Red Hat Ansible Automation Platform from the Amazon Web Services (AWS) Marketplace to automatically provision AWS resources.&lt;/p&gt; &lt;h2&gt;Overview of Ansible Automation Platform on AWS &lt;/h2&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/products/ansible/overview"&gt;Red Hat Ansible Automation Platform&lt;/a&gt; is available on the Amazon Web Services (AWS) Marketplace. It is a self-managed offering that enables enterprise-wide automation with the benefits of deploying &lt;a href="https://www.redhat.com/en/technologies/management/ansible/aws" target="_blank"&gt;Ansible Automation Platform on AWS cloud&lt;/a&gt;. This offering integrates seamlessly with native AWS services and the full Ansible collection for AWS, co-developed and security-tested by AWS and Red Hat.&lt;/p&gt; &lt;p&gt;By combining the power of Red Hat Enterprise Linux, Red Hat OpenShift, and AWS services, developers can effectively scale their cloud infrastructure and leverage technologies such as containers, Kubernetes, and hybrid cloud architecture. The collaboration between Red Hat and AWS offers a hybrid cloud environment that simplifies IT management, reduces complexity, and streamlines innovation.&lt;/p&gt; &lt;h2&gt;4 Components of Ansible Automation Platform&lt;/h2&gt; &lt;p&gt;You can obtain the Ansible Automation Platform offering from &lt;a href="https://aws.amazon.com/marketplace/pp/prodview-l36q6uvlouwb4?sr=0-1&amp;ref_=beagle&amp;applicationId=AWSMPContessa"&gt;AWS Marketplace&lt;/a&gt;. Once you have the subscription, refer to the comprehensive &lt;a href="https://access.redhat.com/documentation/en-us/ansible_on_clouds/2.x/html/red_hat_ansible_automation_platform_from_aws_marketplace_guide/assembly-aap-aws-install"&gt;documentation guide&lt;/a&gt; to set up and configure your Ansible Automation Platform on AWS.&lt;/p&gt; &lt;p&gt;The following is an overview of four components of Ansible Automation Platform.&lt;/p&gt; &lt;h3&gt;1. Execution environment&lt;/h3&gt; &lt;p&gt;Ansible Playbooks run on the execution environment platform. It includes everything needed to run the Ansible Automation Platform, including the runtime environment and dependencies. The Ansible Automation Platform provides a default execution environment that includes many commonly used modules and plugins.&lt;/p&gt; &lt;p&gt;However, you can also create custom execution environments tailored to your specific needs (Figure 1). This allows you to include only the modules and plugins required for your use case, reducing the size of the environment and minimizing security risks. You can manage the execution environment through the Ansible Automation Platform web console or the execution environment builder.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_11-58-11.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_11-58-11.png?itok=xXki-AuG" width="600" height="295" alt="A screenshot of the execution environment page of Ansible Automation Platform." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The execution environment page of Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;To learn more about the execution environment and execution environment builder, refer to the &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/execution_environments.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;h3&gt;2. Inventories&lt;/h3&gt; &lt;p&gt;An inventory is a collection of hosts and groups managed and orchestrated by Ansible Automation Platform. It is used to define and organize the hosts and groups, targeted during an automation job. An inventory can be a static file, a dynamic inventory script, or an inventory plugin.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;A static inventory file is a simple text file that lists the hosts and their attributes.&lt;/li&gt; &lt;li&gt;A dynamic inventory script retrieves the inventory information from a third-party system or cloud provider in real time.&lt;/li&gt; &lt;li&gt;Inventory plugins provided for specific platforms, such as Amazon Web Services (AWS) and Microsoft Azure.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;In addition to hosts and groups, an inventory can also contain variables that are specific to a host or group. These variables can be used to customize how Ansible interacts with each host or group during a job.&lt;/p&gt; &lt;p&gt;As shown in Figure 2, inventories can be created, imported, and synchronized from external sources, such as cloud providers and configuration management databases (CMDBs). To learn more about Inventories and how to create, manage, and work with them, refer to the official &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/inventories.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-05-22_10-23-30.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-05-22_10-23-30.png?itok=vznwedUp" width="600" height="281" alt="The Inventory page in Ansible Automation Platform." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: The Inventory page in Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;3. Credentials&lt;/h3&gt; &lt;p&gt;In the credentials section of Ansible Automation Platform, you can manage and store sensitive information, such as usernames, passwords, and private keys. These credentials can be used in your playbooks and roles to authenticate with remote hosts, cloud providers, Kubernetes and OpenShift clusters, and other systems.&lt;/p&gt; &lt;p&gt;You can create a variety of credential types, such as SSH, sudo, AWS access keys, tokens, certificates, endpoints, and more. These credentials can be associated with a specific organization, project, or even a specific playbook or role. By using the credential section, you can centrally manage and secure your sensitive data, making it easier to rotate or revoke credentials as needed.&lt;/p&gt; &lt;p&gt;To learn more about using credentials in Ansible Automation Platform, refer to the official &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/credentials.html"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;h3&gt;4. Projects&lt;/h3&gt; &lt;p&gt;In the projects section of Ansible Automation Platform, you can manage your automation content, including playbooks, roles, collections, modules, and plugins. A project is a collection of related content, such as all the playbooks, roles, and other files that are related to a specific task or application.&lt;/p&gt; &lt;p&gt;Projects can be created and managed through the Ansible Automation Platform web UI or by utilizing the AWX CLI tool. They can be associated with a source control repository, such as Git or SVN, for version control and collaborative development.&lt;/p&gt; &lt;p&gt;Once you have a project set up, you can easily manage and organize your automation content, collaborate with other users, and ensure that your automation runs consistently across your infrastructure. You can also use projects to deploy automation content to remote servers, such as virtual machines or containers, for testing and production use.&lt;/p&gt; &lt;p&gt;For more information on managing projects in Ansible Automation Platform, you can refer to the &lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/projects.html"&gt;user guide&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Job and workflow templates &lt;/h2&gt; &lt;p&gt;Job templates and workflow templates are powerful features of the Ansible Automation Platform that enable IT teams to automate and orchestrate their infrastructure management tasks.&lt;/p&gt; &lt;p&gt;A job template is a predefined set of tasks that can be executed on one or more hosts, making it a powerful tool for automating repetitive tasks, such as software installations or configuration changes. With job templates, we can define the tasks to be executed, the hosts on which they should run, and any required input parameters, all through an intuitive user interface.&lt;/p&gt; &lt;p&gt;On the other hand, workflow templates allow you to chain together multiple job templates to create a more complex process or workflow. With workflow templates, you can automate even the most complex tasks, such as deploying a multi-tiered application with multiple components and dependencies.&lt;/p&gt; &lt;p&gt;Together, job and workflow templates provide a comprehensive automation solution that streamlines IT operations and ensures that your infrastructure is configured and maintained consistently and efficiently.&lt;/p&gt; &lt;h2&gt;Find more resources&lt;/h2&gt; &lt;p&gt;To learn about using&lt;strong&gt; &lt;/strong&gt;job templates to create Amazon Web Services (AWS) EC2 instances with Ansible Automation Platform, check out our step-by-step guide for &lt;a href="https://developers.redhat.com/articles/2023/04/28/step-step-guide-creating-amazon-web-services-aws-ec2-instance-using-ansible"&gt;How to create an EC2 instance in AWS using Ansible automation&lt;/a&gt;. For information on creating instances using workflow templates, read the article, &lt;a href="https://developers.redhat.com/articles/2023/04/28/step-step-guide-creating-amazon-web-services-aws-ec2-instance-workflow-using"&gt;How to create an EC2 instance in AWS using Ansible workflow&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;If you want understand automation more in-depth, refer to the &lt;a href="https://developers.redhat.com/e-books/it-executives-guide-automation"&gt;IT Executive's Guide to Automation&lt;/a&gt; e-book, which provides a comprehensive overview of automation and its impact on businesses. If you're new to Ansible Automation Platform, you can &lt;a href="https://developers.redhat.com/products/ansible/download"&gt;download&lt;/a&gt; it and &lt;a href="https://developers.redhat.com/products/ansible/getting-started"&gt;get started by exploring interactive labs&lt;/a&gt; at no cost.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/08/10/benefits-deploying-ansible-automation-platform-aws" title="The benefits of deploying Ansible Automation Platform on AWS"&gt;The benefits of deploying Ansible Automation Platform on AWS&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Deepankar Jain, Himanshu Yadav</dc:creator><dc:date>2023-08-10T07:00:00Z</dc:date></entry><entry><title>The process of migrating Java applications</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/08/09/process-migrating-java-applications" /><author><name>Mudassar Iqbal</name></author><id>57e90918-1b0b-45f8-9acb-f93d4d1aa19e</id><updated>2023-08-09T07:00:00Z</updated><published>2023-08-09T07:00:00Z</published><summary type="html">&lt;p&gt;The migration process is cumbersome, to say the least. The root cause for this can be associated with the ambiguity about the differences that may exist between two vantage points (i.e., origin and destination). Hence in the absence of a knowledgeable, tried, and tested roadmap, one simply cannot identify the gaps that are to be bridged while moving from origin to the destination. Same goes for software migration. A software migration process must factor in the changes it expects to undergo while migrating (i.e., downgrading, upgrading, or switching between two different and/or compatible/incompatible versions of the same or different brands). The key to success for such a venture lies in knowing the unknowns alongside their respective impact to its surroundings. Only then can an effective list of changes be identified and implemented.&lt;/p&gt; &lt;p&gt;Recently, I had the opportunity to work on the same lines where few enterprises were looking to move away from an incumbent Java Development Kit (JDK) and Java Runtime Environment (JRE) in favor of the Red Hat build of OpenJDK. JDK and JRE are the most critical components of a Java based IT landscape and can inflict widespread impact to its dependents. While the adapted process during these engagements was specific to Red Hat build of OpenJDK, migration between other JDKs and softwares can also draw inspiration from it.&lt;/p&gt; &lt;h2&gt;Inventory list&lt;/h2&gt; &lt;p&gt;Like any migration process, the process to migrate to Red Hat build of OpenJDK from any other JDK involves detailed assessment and planning to ensure that all unknowns responsible for causing impact and complexity are identified and dealt with carefully. The assessment process should always start by listing the inventory.&lt;/p&gt; &lt;p&gt;Before migrating, we need to identify every single component that may face an impact, including computers, servers (bare metal and/or virtual machines), workstations (physical or virtual desktops and/or laptops), Java processes (application servers, binary executables, CI/CD pipelines and more importantly the business applications). In terms of business applications, a distinction must be made between the ones developed and maintained in-house or procured from a third-party vendor. The reason for this will be discussed later under Application Migration. Long story short, anything that is impacted by a change in Java version or vendor must be listed as an item to the inventory.&lt;/p&gt; &lt;h2&gt;Artifact screening&lt;/h2&gt; &lt;p&gt;Human errors are probably the most common factor contributing to a failure. Although inventory is usually documented by someone who knows the whole infrastructure well, still there is a possibility to miss something. This possibility appears more probable for some less frequently utilized or upgraded Java based artifact. To eliminate this, simple automation can be effective. For example, a simple automation process can be developed that scans every single host to locate files of type Jar, War, or Ear. This can be very easily achieved with the help of a commonly available scripting technology like bash, PowerShell or Red Hat Ansible Automation Platform, etc.&lt;/p&gt; &lt;h2&gt;Automate Java installation&lt;/h2&gt; &lt;p&gt;One of the most critical tasks during JDK/JRE migration is the installation of the binaries for the intended Java version released by the preferred vendor. However, this process is extremely laborious. What makes it complex is the varsity and size associated with the targeted infrastructure. For example, even the infrastructure maintained by small to medium sized enterprises is a handful, let alone the larger enterprises. The reasons for this are multifold. Hardware infrastructure consists of a large number of computers that may run different types of operating systems (i.e., servers usually operate with Linux or Windows whereas workstations can run macOS or Windows).&lt;/p&gt; &lt;p&gt;Additionally, Java is made available for installation in different ways. Some organizations allow direct download, some make it available for installation via an internal marketplace, and some organizations ensure that it is installed while provisioning the workstation. On top of this, different vendors release different packaging like RPM, binary archive, or even a graphical installer.&lt;/p&gt; &lt;p&gt;All these multidimensional facts suggest that each installation task must be handled uniquely. As each host is expected to be migrated to a newer Java brand and/or version individually, the installation process must be capable of successfully repeating itself without failing. Hence, automation using a tool like Ansible Automation Platform is the key to success.&lt;/p&gt; &lt;h2&gt;Application migration&lt;/h2&gt; &lt;p&gt;Probably the most critical task of JDK/JRE migration is to make in-house and third-party business applications compatible with newer versions and/or brands of Java. As JDK/JRE provide compile time as well as runtime support to these applications, these components are expected to endure the majority of the impact. One can draw comfort from a simple rule, cross vendor migration between competing versions may inflict minimal to no impact at all. However with the wider gaps between two versions, the impact is also expected to be greater considering that implementation may have changed and the libraries, classes, methods, etc. may have been deprecated and/or replaced. Yet we need a better approach to handle this task.&lt;/p&gt; &lt;p&gt;Third-party applications cannot be upgraded or compiled in-house. This is why the vendor(s) should be providing clarity around these applications if they are tested and supported by them with the Java version/brand intended to provide the runtime and/or compile time support. In case there is a need for some patch work or upgrade, it should also be handled by the respective vendor(s).&lt;/p&gt; &lt;p&gt;Contrary to third-party applications, in-house applications are designed, developed, and maintained by the enterprise. These applications must undergo an assessment for the expected impact. Windup or migration toolkit for applications are good tools for this purpose. This will identify the changes needed for successful compilation of the source code to operate with the intended JRE.&lt;/p&gt; &lt;h2&gt;Delivery and verification&lt;/h2&gt; &lt;p&gt;Now that we have the infrastructure migrated to operate with a newer or different version or brand of Java, development environment alongside CI/CD pipelines are migrated to use intended Java version or brand during development and compilation time. Business applications are refactored alongside unit tests. It is still strongly recommended to verify everything for functional correctness. Once the business applications have passed the verification phase, migration can be deemed successful.&lt;/p&gt; &lt;h2&gt;Navigating the software migration process&lt;/h2&gt; &lt;p&gt;Even though software migration involves uncertainty, there are methods and tools available to deal with it. What matters is how effectively you utilize these methodologies and technologies.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/08/09/process-migrating-java-applications" title="The process of migrating Java applications"&gt;The process of migrating Java applications&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Mudassar Iqbal</dc:creator><dc:date>2023-08-09T07:00:00Z</dc:date></entry><entry><title type="html">DMN boxed expression editor improvements</title><link rel="alternate" href="https://blog.kie.org/2023/08/dmn-boxed-expression-editor-improvements.html" /><author><name>Jozef Marko</name></author><id>https://blog.kie.org/2023/08/dmn-boxed-expression-editor-improvements.html</id><updated>2023-08-08T14:11:16Z</updated><content type="html">We are happy to announce another set of improvements to our boxed expression editor. As we unveiled recently in the , we try to improve the boxed expression editor continuously. Described features from this article will be available with release. So let’s have a look at them in more detail. AUTOCOMPLETION Autocompletion appears automatically as the user starts to type the text of the expression. These autocompletion are filtered to match the typed text. As an alternative, the user can invoke autocompletion simply by pressing Ctrl + Spacebar (the shortcut may differ on various platforms). BEFORE AND NOW Older versions of the DMN boxed expression editor suggested a raw list of available FEEL functions to the user. We can understand raw as missing any documentation of the function. However now, thanks to , we added documentation for each available function containing details of parameters and returned value. ROWS AND COLUMNS INSERTION Row or column insertion is an operation a DMN modeler user executes daily. It can be done using an inline plus icon or context menu, that is invoked by a right mouse button click, from most of the boxed expression editor cells. BEFORE AND NOW Older versions of the DMN boxed expression editor allowed single row or column insertion per time. Creation of large expressions this way is slow, not efficient enough. However now, thanks to , users are able to insert as many columns or rows per time as they want. Well, we actually set an upper boundary of 500 items, we believe this boundary is sufficient. These new boxed expression editor improvements will be available soon in the next release. If you spot any issue feel free to contact us on or report an on GitHub. The post appeared first on .</content><dc:creator>Jozef Marko</dc:creator></entry><entry><title>How to monitor workloads using OpenShift monitoring stack</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/08/08/how-monitor-workloads-using-openshift-monitoring-stack" /><author><name>Jude Niroshan</name></author><id>cb65c017-d049-40bf-8af6-eda4b988872d</id><updated>2023-08-08T07:00:00Z</updated><published>2023-08-08T07:00:00Z</published><summary type="html">&lt;p&gt;The out-of-the-box monitoring stack in Red Hat OpenShift provides a comprehensive set of tools and services to monitor various aspects of your workloads, including metrics, logs, events, and traces. With this monitoring stack, you can gain valuable insights into the health and performance of your applications, identify and troubleshoot issues, and optimize resource utilization. This allows you to deliver a seamless user experience and confidently meet your business objectives.&lt;/p&gt; &lt;p&gt;In this article, we will explore the monitoring stack in Red Hat OpenShift and how to use it to monitor a sample application effectively using &lt;a href="https://prometheus.io"&gt;Prometheus&lt;/a&gt; and &lt;a href="https://grafana.com/oss/grafana"&gt;Grafana&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;How to monitor a sample application&lt;/h2&gt; &lt;p&gt;We will use an OpenShift cluster with version 4.10.36 in this example.&lt;/p&gt; &lt;h3&gt;Step 1: Create a ConfigMap&lt;/h3&gt; &lt;p&gt;Create a ConfigMap in the openshift-monitoring namespace.&lt;/p&gt; &lt;p&gt;In OpenShift, user workload refers to the applications and services that users deploy onto the cluster. Before we begin, we need to create a ConfigMap in the openshift-monitoring namespace to enable user workload monitoring.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: v1 kind: ConfigMap metadata: name: cluster-monitoring-config namespace: openshift-monitoring data: config.yaml: | enableUserWorkload: true&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Step 2: Check for Prometheus&lt;/h3&gt; &lt;p&gt;Check openshift-user-workload-monitoring namespace for the new Prometheus server pod (Figure 1).&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image_article_1.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/image_article_1.png?itok=pneaClZJ" width="600" height="175" alt="A screenshot of the Prometheus server pod in OpenShift Container Platform.." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The Prometheus server pod is located in the Pod page.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;After creating the ConfigMap, check the openshift-user-workload-monitoring namespace for a new Prometheus server pod.&lt;/p&gt; &lt;h3&gt;Step 3: Deploy Java application&lt;/h3&gt; &lt;p&gt;Deploy the example Java application as a deployment with an OCP route.&lt;/p&gt; &lt;p&gt;A &lt;a href="https://github.com/JudeNiroshan/coin-toss-api"&gt;sample Java applicatio&lt;/a&gt;n has been developed that provides an API for coin-tossing. This API exposes the number of times the heads side of the coin showed, represented as a coin_heads_total metric of counter type in Prometheus. The &lt;a href="https://quarkus.io/guides/micrometer"&gt;MicroMeter Quarkus extension&lt;/a&gt; has been utilized to expose this metric. The metrics can be accessed via the http://localhost:8080/q/metrics endpoint if the application starts locally. The application has been containerized and is available to use under &lt;strong&gt;quay.io/jnirosha/coin-toss-api&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;Next, deploy the coin-toss-api as a deployment with an OpenShift route. Use the following command to deploy the application:&lt;/p&gt; &lt;p&gt;&lt;code&gt;oc new-app --name=coin-toss-api quay.io/jnirosha/coin-toss-api&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;oc expose svc/coin-toss-api&lt;/code&gt;&lt;/p&gt; &lt;h3&gt;Step 4: Create a ServiceMonitor instance&lt;/h3&gt; &lt;p&gt;Create a ServiceMonitor instance to register the Prometheus target.&lt;/p&gt; &lt;p&gt;To monitor the coin-toss-api application, we must create a ServiceMonitor instance to register the Prometheus target. Run the following command to create the ServiceMonitor:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata:   name: my-service-monitor   namespace: my-project spec:   endpoints:     - interval: 5s       path: /q/metrics       port: 8080-tcp       scheme: http   namespaceSelector:     matchNames:       - my-project   selector:     matchLabels:       app: coin-toss-api&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Step 5: Filter targets&lt;/h3&gt; &lt;p&gt;After creating the ServiceMonitor, navigate to the Prometheus UI by clicking on the &lt;strong&gt;Observe&lt;/strong&gt; tab in the OpenShift console. Under the &lt;strong&gt;Targets&lt;/strong&gt; menu, filter the targets by the user (Figure 2).&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image_article_2.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/image_article_2.png?itok=tCSNn6Vc" width="600" height="295" alt="A screenshot of the filter tool under the targets tab." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: Click on the Observe and Targets tab to filter metrics targets.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Step 6: Observe metrics&lt;/h3&gt; &lt;p&gt;Navigate to the &lt;strong&gt;Observe&lt;/strong&gt; tab in the OpenShift console, then select &lt;strong&gt;Metrics&lt;/strong&gt; options (Figure 3).&lt;/p&gt; &lt;p&gt;In the expressions input field, you can type &lt;code&gt;coin_heads_total&lt;/code&gt;, which is our custom metric name.&lt;/p&gt; &lt;p&gt;Then click the &lt;strong&gt;Run queries&lt;/strong&gt; button.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image_article_3.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/image_article_3.png?itok=-HZlQ3PO" width="600" height="303" alt="Custom metric in Openshift console" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 3: Run Query&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;At this point, we have two different Prometheus server instances. One is for default OpenShift monitoring, and the other is for user workload monitoring. In OpenShift, to observe metrics, we can see metrics scraped through both the Prometheus server instances (Figure 4).&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/diagram.jpeg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/diagram.jpeg?itok=__RrRn5G" width="600" height="496" alt="A diagram showing the two Prometheus server instances." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 4: The two Prometheus server instances for workload monitoring.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Step 7: Install the Grafana operator&lt;/h3&gt; &lt;p&gt;Install the Grafana operator in a different namespace. To install the Grafana operator, we recommend creating a new namespace. Run the following command to create the namespace as follows:&lt;/p&gt; &lt;p&gt;&lt;code&gt;oc create namespace my-grafana&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Then, install the Grafana operator using OperatorHub.&lt;/p&gt; &lt;h3&gt;Step 8: Create a Grafana instance&lt;/h3&gt; &lt;p&gt;Create a Grafana instance from the operator.&lt;/p&gt; &lt;p&gt;After installing the Grafana operator (v4.9.0), create a Grafana instance by running the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: integreatly.org/v1alpha1 kind: Grafana metadata:   name: my-grafana   namespace: my-grafana spec:   config:     security:       admin_user: admin       admin_password: my-password dataStorage: accessModes: - ReadWriteOnce class: gp2 size: 1Gi   ingress:     enabled: true     tls:       enabled: true&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Configure Grafana to use an ingress with TLS enabled and setting an admin username and password. Make sure to replace "my-password" with a strong password.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Note: &lt;/strong&gt;Please ensure that you include the available storage class in your cluster within the &lt;code&gt;dataStorage&lt;/code&gt; section.&lt;/p&gt; &lt;h3&gt;Step 9: Create a cluster role&lt;/h3&gt; &lt;p&gt;Create a cluster role binding to the grafana-serviceaccount.&lt;/p&gt; &lt;p&gt;To allow Grafana to access monitoring data in the OpenShift cluster, we need to create a cluster role binding to the grafana-serviceaccount.&lt;/p&gt; &lt;p&gt;Run the following command:&lt;/p&gt; &lt;p&gt;&lt;code&gt;oc create clusterrolebinding grafana-view --clusterrole=cluster-monitoring-view --serviceaccount=my-grafana:grafana-serviceaccount&lt;/code&gt;&lt;/p&gt; &lt;p&gt;This command creates a cluster role binding named grafana-view that provides the cluster-monitoring-view role to the grafana-serviceaccount in all namespaces.&lt;/p&gt; &lt;h3&gt;Step 10: Generate a token&lt;/h3&gt; &lt;p&gt;Generate a token using the grafana-serviceaccount.&lt;/p&gt; &lt;p&gt;To authenticate with the OpenShift API, Grafana needs a token generated from the grafana-serviceaccount. Run the following command to generate a token:&lt;/p&gt; &lt;p&gt;&lt;code&gt;export TOKEN=$(oc create token grafana-serviceaccount -n my-grafana) &lt;/code&gt;&lt;/p&gt; &lt;p&gt;Then view the token using:&lt;/p&gt; &lt;p&gt;&lt;code&gt;echo $TOKEN&lt;/code&gt;&lt;/p&gt; &lt;h3&gt;Step 11: Create a GrafanaDataSource instance&lt;/h3&gt; &lt;p&gt;Create a GrafanaDataSource instance from the operator.&lt;/p&gt; &lt;p&gt;Finally, create a GrafanaDataSource instance from the operator to connect Grafana to Prometheus. Run the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: integreatly.org/v1alpha1 kind: GrafanaDataSource metadata:   name: prometheus   namespace: my-grafana spec:   datasources:     - basicAuthUser: internal       access: proxy       editable: true       secureJsonData:         httpHeaderValue1: &gt;-           Bearer &lt;&lt;paste-your-generated-token-here&gt;&gt;       name: Prometheus       url: 'https://thanos-querier.openshift-monitoring.svc.cluster.local:9091'       jsonData:         httpHeaderName1: Authorization         timeInterval: 5s         tlsSkipVerify: true       basicAuth: false       isDefault: true       version: 1       type: prometheus   name: test_name&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Log in to the Grafana dashboard and check data sources. You should see an entry like Figure 5. This is the data source we created using the custom resource in the operator.&lt;/p&gt; &lt;p&gt;Ensure that the Grafana can extract metrics from the Prometheus servers.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image_article_5.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/image_article_5.png?itok=87MRjNry" width="600" height="548" alt="A screenshot of the Grafana dashboard." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 5: The data source in the Grafana dashboard is displayed.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Once everything is working as expected, you can create your own Grafana dashboard. Figure 6 shows a simple graph I created inside the Grafana. It shows how many times the heads have appeared so far when tossing the coin in our Java application.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_2023-03-13_at_11.42.14.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_2023-03-13_at_11.42.14.png?itok=R1Olh8dT" width="600" height="282" alt="A Grafana graph created to show the number of coins tossed." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 6: Grafana graph&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;The OpenShift monitoring stack is easy to use&lt;/h2&gt; &lt;p&gt;In conclusion, using a monitoring stack on the Red Hat OpenShift platform is easy and straightforward. One of the major advantages of this platform is that it comes out of the box with all the essential components necessary to enable effective monitoring of your applications and infrastructure. With just a few configuration settings, you can easily set up monitoring tools like Prometheus, Grafana, and alert manager to provide insights into the performance and health of your applications.&lt;/p&gt; &lt;p&gt;Overall, the OpenShift platform provides a powerful and easy-to-use monitoring stack that simplifies the process of monitoring complex applications and infrastructure. With the ability to customize and extend the platform's monitoring capabilities, you can easily create a monitoring solution that meets the specific needs of your organization.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/08/08/how-monitor-workloads-using-openshift-monitoring-stack" title="How to monitor workloads using OpenShift monitoring stack"&gt;How to monitor workloads using OpenShift monitoring stack&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Jude Niroshan</dc:creator><dc:date>2023-08-08T07:00:00Z</dc:date></entry></feed>
